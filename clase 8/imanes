import pyvisa as visa
import numpy as np
import time
import pandas as pd
from os import walk

import matplotlib.pyplot as plt
#%%
rm = visa.ResourceManager()

print(rm.list_resources())


resource_name_osci = 'USB0::0x0699::0x03C4::C010501::INSTR'
resource_name_fungen =  'USB0::0xF4EC::0xEE38::SDG1XCA4161035::INSTR'
osci = rm.open_resource(resource_name_osci)
fungen = rm.open_resource(resource_name_fungen)

print(osci.query('*IDN?'))
print(fungen.query('*IDN?'))
#%%
fungen.write('SOURCE1:FREQ 16')
fungen.write('SOURCE1:VOLT 5')

#%%
osci.write('MEASUREMENT:IMMED:SOURCE CH1')
osci.write('MEASUrement:IMMed:TYPe FREQUENCY')
osci.query('MEASUrement:IMMed:VALue?')

#%%
n=0
#%%
#osci.write("AUTOS EXEC")
#time.sleep(4);

osci.write("DAT:SOU CH1")
xze, xin = osci.query_ascii_values('WFMPRE:XZE?;XIN?', separator=';')

osci.write("DAT:SOU CH1")
yze1, ymu1, yoff1 = osci.query_ascii_values('WFMPRE:YZE?;YMU?;YOFF?;', separator=';')

osci.write("DAT:SOU CH2")
yze2, ymu2, yoff2 = osci.query_ascii_values('WFMPRE:YZE?;YMU?;YOFF?;', separator=';')


osci.write("DAT:SOU CH1")
data1 = osci.query_binary_values('CURV?', datatype='B', container=np.array)

osci.write("DAT:SOU CH2")
data2 = osci.query_binary_values('CURV?', datatype='B', container=np.array)


data1v = (data1 - yoff1) * ymu1 + yze1
data2v = (data2 - yoff2) * ymu2 + yze2

tiempo = xze + np.arange(len(data1v)) * xin

df = pd.DataFrame(dict(tiempo=tiempo, ch1=data1v))

file_name = "cualitativo_mov_manual"

df.to_pickle(f'df_{file_name}.pkl')  

plt.plot(df["tiempo"],df["ch2"] )
plt.scatter(df["tiempo"],df["ch1"] )

#%%

#time.sleep(8);
#print(f'Termine de esperar. Freq {freq}')

osci.write("DAT:SOU CH1")
xze, xin = osci.query_ascii_values('WFMPRE:XZE?;XIN?', separator=';')

osci.write("DAT:SOU CH1")
yze1, ymu1, yoff1 = osci.query_ascii_values('WFMPRE:YZE?;YMU?;YOFF?;', separator=';')

osci.write("DAT:SOU CH2")
yze2, ymu2, yoff2 = osci.query_ascii_values('WFMPRE:YZE?;YMU?;YOFF?;', separator=';')


osci.write("DAT:SOU CH1")
data1 = osci.query_binary_values('CURV?', datatype='B', container=np.array)

osci.write("DAT:SOU CH2")
data2 = osci.query_binary_values('CURV?', datatype='B', container=np.array)

vpk2vpk_ch1 = osci.query('MEASU:MEAS1:VAL?')
vpk2vpk_ch2 = osci.query('MEASU:MEAS2:VAL?')
phase = osci.query('MEASU:MEAS3:VAL?')

data1v = (data1 - yoff1) * ymu1 + yze1
data2v = (data2 - yoff2) * ymu2 + yze2

tiempo = xze + np.arange(len(data1v)) * xin

df = pd.DataFrame(dict(tiempo=tiempo, ch1=data1v, ch2=data2v))

    # con esto puedo poner metadata
df.attrs["frecuencia"] = 2000
df.attrs["volt"] = 10
df.attrs["vpeak_ch1"] = vpk2vpk_ch1
df.attrs["vpeak_ch2"] = vpk2vpk_ch2
df.attrs["phase"] = phase

bob1=3200
bob2=1600

df.attrs["coci_vol12"] = float(vpk2vpk_ch2)/float(vpk2vpk_ch1)
df.attrs["coci_n12"] = bob1/bob2



print(f'La fase es {phase}')
print(f'El voltaje pk2pk del ch2 es {vpk2vpk_ch2}')

df.to_pickle(f'df_trans_in{bob1}_out{bob2}.pkl')

#%%
phase_list =  []
ch1_peak = []
ch2_peak = []

for freq in np.linspace(25000, 40000, 20):
    fungen.write(f'C1:BSWV FRQ, {freq}')
    print("Inicio espera y autoset")
    osci.write("AUTOS EXEC")
    time.sleep(5);
    print(f'Termine de esperar. Freq {freq}')
    
    osci.write("DAT:SOU CH1")
    xze, xin = osci.query_ascii_values('WFMPRE:XZE?;XIN?', separator=';')
    
    osci.write("DAT:SOU CH1")
    yze1, ymu1, yoff1 = osci.query_ascii_values('WFMPRE:YZE?;YMU?;YOFF?;', separator=';')

    osci.write("DAT:SOU CH2")
    yze2, ymu2, yoff2 = osci.query_ascii_values('WFMPRE:YZE?;YMU?;YOFF?;', separator=';')
    
    
    osci.write("DAT:SOU CH1")
    data1 = osci.query_binary_values('CURV?', datatype='B', container=np.array)
    
    osci.write("DAT:SOU CH2")
    data2 = osci.query_binary_values('CURV?', datatype='B', container=np.array)
    
    vpk2vpk_ch2 = osci.query('MEASU:MEAS1:VAL?')
    vpk2vpk_ch1 = osci.query('MEASU:MEAS2:VAL?')
    phase = osci.query('MEASU:MEAS3:VAL?')
    
    data1v = (data1 - yoff1) * ymu1 + yze1
    data2v = (data2 - yoff2) * ymu2 + yze2
    
    tiempo = xze + np.arange(len(data1v)) * xin
    
    df = pd.DataFrame(dict(tiempo=tiempo, ch1=data1v, ch2=data2v))
    
    res = {"value": 9000, "unidad": "ohm"}
    
        # con esto puedo poner metadata
    df.attrs["frecuencia"] = freq
    df.attrs["volt"] = 10
    df.attrs["vpeak_ch1"] = vpk2vpk_ch1
    df.attrs["vpeak_ch2"] = vpk2vpk_ch2
    df.attrs["phase"] = phase
    
    print(f'La fase es {phase}')
    print(f'El voltaje pk2pk del ch2 es {vpk2vpk_ch2}')
    
    df.attrs["resistencia"] = res
    
    df.to_pickle(f'df_barridohierro_{freq}.pkl')
    
    phase_list.append(phase)
    ch1_peak.append(vpk2vpk_ch1)
    ch2_peak.append(vpk2vpk_ch2)
#%%

plt.scatter(df['tiempo'], df['ch1'])

#%%
coci_vol_1 = []
coci_n_1 = []

for (dirpath, dirnames, filenames) in walk("med_arco_cerrado"):
    for filename in filenames:    
        df = pd.read_pickle(f'{dirpath}/{filename}')
        coci_vol_1.append(1/df.attrs["coci_vol12"])
        coci_n_1.append(df.attrs["coci_n12"])

coci_vol_2 = []
coci_n_2 = []

for (dirpath, dirnames, filenames) in walk("med_arco_triple_abierto"):
    for filename in filenames:    
        df = pd.read_pickle(f'{dirpath}/{filename}')
        coci_vol_2.append(1/df.attrs["coci_vol12"])
        coci_n_2.append(df.attrs["coci_n12"])        



x_datos1 = np.asarray(coci_n_1)
y_datos1 = np.asarray(coci_vol_1)

x_datos2 = np.asarray(coci_n_2)
y_datos2 = np.asarray(coci_vol_2)


pars, cov = np.polyfit(x_datos1, y_datos1,deg=1,cov=True)
m, b = pars
Sm, Sb = np.sqrt( np.diag(cov) )

ajuste1 = b + x_datos1 * m
print(f'datos ajuste 1: pendiente = {m:.4f} ± {Sm:.4f}, ordenada = {b:.4f} ± {Sb:.4f}')


pars, cov = np.polyfit(x_datos2, y_datos2,deg=1,cov=True)
m, b = pars
Sm, Sb = np.sqrt( np.diag(cov) )

ajuste2 = b + x_datos2 * m
print(f'datos ajuste 2: pendiente = {m:.4f} ± {Sm:.4f}, ordenada = {b:.4f} ± {Sb:.4f}')


plt.scatter(x_datos1, y_datos1,label='Mediciones transformador 1')
plt.plot(x_datos1, ajuste1, label='Ajuste lineal transformador 1')
plt.scatter(x_datos2, y_datos2,label='Mediciones transformador 2')
plt.plot(x_datos2, ajuste2, label='Ajuste lineal transformador 2')
plt.ylabel('Cociente Vs/Vp')
plt.xlabel('Cociente Ns/Np')
plt.grid()
plt.legend()
        #%%

t = dataframes[0]

ax1 = plt.subplot(3,1,1)

plt.legend()
plt.ticklabel_format(axis='both',style = "sci" ,scilimits=(-2,2), useOffset=False, useLocale=False, useMathText=False)
ax1 = plt.subplot(3,1,2)
plt.ylabel('Voltaje[V]')
plt.plot(dataframes[5]['tiempo'], dataframes[5]['ch1'], label = "1668.1 Hz",color = "green")
plt.legend()
plt.ticklabel_format(axis='both',style = "sci" ,scilimits=(-2,2), useOffset=False, useLocale=False, useMathText=False)
ax1 = plt.subplot(3,1,3)
plt.plot(dataframes[9]['tiempo'], dataframes[9]['ch1'],label = "100kHz",color = "red")
plt.legend()

plt.xlabel('Tiempo[s]')

#%%
    
n = 1;
for dataframe in dataframes:
    dataframe.to_csv('df_%f' % n, sep='\t')
    n=n+1
    #plt.scatter(dataframe['ch1'], dataframe['ch1']-dataframe['ch2'], s=5)

#%%
ax1 = plt.subplot(2,1,1)
plt.errorbar(x_datos, y_datos, xerr=x_err, yerr=y_err, fmt='.', label='mediciones')
plt.plot(x_datos, ajuste, label='ajuste')
plt.grid()

plt.ylabel('Corriente[mA]')
plt.legend()

plt.subplot(2,1,2, sharex=ax1)

plt.errorbar(x_datos, y_datos - ajuste, xerr=x_err, yerr=y_err, fmt='.')
plt.xlabel('Voltaje[V]')
plt.ylabel('Residuos [mA]')
plt.grid()

#%%
cociente = []
phase_list_float = [float(i) for i in phase_list]
freq_list = np.logspace(2, 3.7, 15)

for i in range(0, len(ch1_peak)):
    cociente.append(float(ch2_peak[i])/float(ch1_peak[i]))
    
plt.scatter(freq_list, cociente)
df = pd.DataFrame(dict(frecuencia=freq_list, transferencia=cociente, phase=phase_list_float))
df.to_pickle(f'df_pasa_bajo_med2.pkl')


#%%

phase_list_float = [float(i) for i in phase_list]
cociente = []

freq_list = np.logspace(2, 3.7, 15)

plt.scatter(freq_list, phase_list_float)
#%%
pasa_alto = pd.read_pickle('pasa_alto/df_pasa_alto.pkl')
pasa_bajo = pd.read_pickle('pasa_bajo/df_freq_transferecia.pkl')
pasa_bajo_med2 = pd.read_pickle('pasa_bajo/df_pasa_bajo_med2.pkl')

pasa_bajo = pasa_bajo.append(pasa_bajo_med2)

ganancia_pasa_alto = 20*np.log(pasa_alto['transferencia'])
ganancia_pasa_bajo = 20*np.log(pasa_bajo['transferencia'])

#ganancia_pasa_bajo.loc[lambda x : x < -15]

frecuencia = np.asarray(pasa_bajo['frecuencia'])
mask = frecuencia <= 36000

frecuencia_filtrada = frecuencia[mask]
ganancia_pasa_bajo_filtrado = ganancia_pasa_bajo[mask]

plt.title("Circuito RC como filtro")

plt.xscale("log")
plt.ylabel('Ganancia[dB]')
plt.xlabel('Frecuencia[Hz]')
plt.scatter(pasa_alto['frecuencia'], ganancia_pasa_alto, label = "Pasa alto")
plt.scatter(frecuencia_filtrada, ganancia_pasa_bajo_filtrado, label = "Pasa bajo")
plt.legend()
#%%

np.asarray()
